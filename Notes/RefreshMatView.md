# Обновление материализованных представлений в Postgresql


Материализованные представления появились в Postgresql версии 9.4 (декабрь 2014 года).
Материализованное представление (Materialized view) является расширением представления (view),  позволяющим сохранить результат выполнения описанного в представлении SQL запроса для последующего использования в других запросах. Это позволяет выполнять сложный/тяжелый запрос гораздо реже. Для обновления результата материализованного представления используется команда refresh materialized view.

Рассмотрим поведение материализованного представления в postgresql 16 при выполнении команды обновления refresh materialized view в обычном и конкурентном режимах.

## Cоздание материализованного представления

Создадим материализованное представление

```sql
create materialized view test as
select book.ride.id, book.bus.model, book.ride.startdate
from book.bus 
inner join book.ride on book.bus.id=book.ride.fkbus;
```

Выполним запрос на получение данных из созданного материализованного представления

```sql
 select * from test order by id desc limit 5;
   id   |   model   | startdate  
 --------+-----------+------------
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
 143997 | Toyota N1 | 2000-04-09
 143996 | Toyota T1 | 2000-04-09
```

## Обновление материализованного представления в транзакции

### В обычном (неконкурентном) режиме

Внесем изменение в таблицу book.ride

```sql
insert into book.ride (startdate, fkbus, fkschedule) values ('2024-06-04', 1, 1);
INSERT 0 1
```

Проверим, что данные в таблице изменились, а в материализованном представлении нет.

```sql
select * from book.ride order by id desc limit 5;
   id   | startdate  | fkbus | fkschedule 
--------+------------+-------+------------
 144003 | 2024-06-04 |     1 |          1
 144000 | 2000-04-09 |     1 |       1440
 143999 | 2000-04-09 |     2 |       1439
 143998 | 2000-04-09 |     1 |       1438
 143997 | 2000-04-09 |     1 |       1437

select * from test order by id desc limit 5;
   id   |   model   | startdate  
--------+-----------+------------
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
 143997 | Toyota N1 | 2000-04-09
 143996 | Toyota T1 | 2000-04-09
```

Откроем второй сеанс работы с сервером БД и в нем в транзакции выполним обновление materialized view. Транзакцию пока завершать не будем

```sql
begin;
BEGIN
refresh materialized view test;
REFRESH MATERIALIZED VIEW
```

В первом сеансе выполним запрос данных из материализованного представления.

```sql
select * from test order by id desc limit 5;
```

Запрос не возвращает никаких данных, так как материализованное представление заблокировано для обновления в транзакции и транзакция не завершена. После завершения транзакции запрос возвращает измененные данные.

```sql
commit;
COMMIT
----
select * from test order by id desc limit 5;
   id   |   model   | startdate  
--------+-----------+------------
 144003 | Toyota N1 | 2024-06-04
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
 143997 | Toyota N1 | 2000-04-09
```

### В конкурентном режиме

Для возможности конкурентного обновления создадим для материализованного представления уникальный индекс по полю id.

```sql
create unique index mv_test_uq_idx on test (id);
```

Внесем изменение в таблицу book.ride

```sql
insert into book.ride (startdate, fkbus, fkschedule) values ('2024-06-04', 2, 1);
INSERT 0 1
```

Проверим, что данные в таблице изменились, а в материализованном представлении нет.

```sql
select * from book.ride order by id desc limit 5;
   id   | startdate  | fkbus | fkschedule 
--------+------------+-------+------------
 144004 | 2024-06-04 |     2 |          1
 144003 | 2024-06-04 |     1 |          1
 144000 | 2000-04-09 |     1 |       1440
 143999 | 2000-04-09 |     2 |       1439
 143998 | 2000-04-09 |     1 |       1438

select * from test order by id desc limit 5;
   id   |   model   | startdate  
--------+-----------+------------
 144003 | Toyota N1 | 2024-06-04
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
 143997 | Toyota N1 | 2000-04-09
```

 Во втором сеансе работы с сервером БД в транзакции выполним конкурентное обновление materialized view. Транзакцию также пока завершать не будем

```sql
begin;
BEGIN
refresh materialized view concurrently test;
REFRESH MATERIALIZED VIEW
```

Отмечаем, что обновление материализованного представления в конкурентном режиме выполняется дольше по времени.
В первом сеансе выполним запрос данных из материализованного представления.

```sql
select * from test order by id desc limit 5;
   id   |   model   | startdate  
--------+-----------+------------
 144003 | Toyota N1 | 2024-06-04
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
 143997 | Toyota N1 | 2000-04-09
```

Запрос возвращает необновленные данные сразу же, хотя транзакция не завершена. После завершения транзакции запрос возвращает измененные данные.

```sql
commit;
COMMIT
----
select * from test order by id desc limit 5;
   id   |   model   | startdate  
--------+-----------+------------
 144004 | Toyota T1 | 2024-06-04
 144003 | Toyota N1 | 2024-06-04
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
 143997 | Toyota N1 | 2000-04-09
```

### Параллельное конкурентное обновление в разных транзакциях

Запускаем конкурентное обновление в первой транзакции, транзакцию оставляем открытой.

```sql
begin;
BEGIN
refresh materialized view concurrently test;
REFRESH MATERIALIZED VIEW
```

Во втором сеансе изменяем данные в таблице ride и запускаем конкурентное обновление

```sql
begin;
BEGIN
refresh materialized view concurrently test;
```

Несмотря не конкурентный режим обновления, запрос ожидает завершения ранее запущенного  в другой транзакции конкурентного обновления. Завершим транзакцию в первом сеансе

```sql
commit;
COMMIT
```

во втором сеансе завершилось обновление материализованного представления. Завершаем транзакцию во втором сеансе и проверяем, что данные в материализованном представлении обновились.

```sql
 refresh materialized view concurrently test;
REFRESH MATERIALIZED VIEW
commit;
COMMIT
select * from test order by id desc limit 5;
   id   |   model   | startdate  
--------+-----------+------------
 144004 | Toyota T1 | 2024-06-04
 144003 | Toyota N1 | 2024-06-04
 144000 | Toyota N1 | 2000-04-09
 143999 | Toyota T1 | 2000-04-09
 143998 | Toyota N1 | 2000-04-09
```

## Заключение

Рассмотрены различные режимы обновления данных материализованного представления. Даже для обновления в конкурентном режиме возможно возникновение блокировки обновления. 

